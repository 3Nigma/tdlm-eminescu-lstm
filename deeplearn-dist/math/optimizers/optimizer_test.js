"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ndarray_1 = require("../../math/ndarray");
var test_util = require("../../test_util");
var sgd_optimizer_1 = require("./sgd_optimizer");
var tests = function (it) {
    it('basic', function (math) {
        var learningRate = .1;
        var optimizer = new sgd_optimizer_1.SGDOptimizer(learningRate);
        var x = ndarray_1.variable(ndarray_1.Scalar.new(4));
        var bias = ndarray_1.variable(ndarray_1.Scalar.new(1));
        var strayVariable = ndarray_1.variable(ndarray_1.Scalar.new(-1));
        var numArrays = math.getNumArrays();
        var f = function () { return math.addStrict(math.square(x), bias); };
        var cost = optimizer.minimize(f, true);
        expect(math.getNumArrays()).toBe(numArrays + 1);
        var expectedX1 = -2 * 4 * learningRate + 4;
        var expectedBias1 = -1 * learningRate + 1;
        test_util.expectArraysClose(x, [expectedX1]);
        test_util.expectArraysClose(bias, [expectedBias1]);
        test_util.expectArraysClose(cost, [Math.pow(4, 2) + 1]);
        test_util.expectArraysClose(strayVariable, [-1]);
        cost.dispose();
        numArrays = math.getNumArrays();
        cost = optimizer.minimize(f, false);
        expect(math.getNumArrays()).toBe(numArrays);
        var expectedX2 = -2 * expectedX1 * learningRate + expectedX1;
        var expectedBias2 = -learningRate + expectedBias1;
        test_util.expectArraysClose(x, [expectedX2]);
        test_util.expectArraysClose(bias, [expectedBias2]);
        expect(cost).toBe(null);
        test_util.expectArraysClose(strayVariable, [-1]);
        optimizer.dispose();
        x.dispose();
        bias.dispose();
        strayVariable.dispose();
        expect(math.getNumArrays()).toBe(0);
    });
    it('varList array of all variables', function (math) {
        var learningRate = .1;
        var optimizer = new sgd_optimizer_1.SGDOptimizer(learningRate);
        var x = ndarray_1.variable(ndarray_1.Scalar.new(4));
        var bias = ndarray_1.variable(ndarray_1.Scalar.new(1));
        var strayVariable = ndarray_1.variable(ndarray_1.Scalar.new(-1));
        var varList = [x, bias];
        var f = function () { return math.addStrict(math.square(x), bias); };
        var cost = optimizer.minimize(f, true, varList);
        var expectedX1 = -2 * 4 * learningRate + 4;
        var expectedBias1 = -1 * learningRate + 1;
        test_util.expectArraysClose(x, [expectedX1]);
        test_util.expectArraysClose(bias, [expectedBias1]);
        test_util.expectArraysClose(cost, [Math.pow(4, 2) + 1]);
        test_util.expectArraysClose(strayVariable, [-1]);
        cost = optimizer.minimize(f, false, varList);
        var expectedX2 = -2 * expectedX1 * learningRate + expectedX1;
        var expectedBias2 = -learningRate + expectedBias1;
        test_util.expectArraysClose(x, [expectedX2]);
        test_util.expectArraysClose(bias, [expectedBias2]);
        test_util.expectArraysClose(strayVariable, [-1]);
        expect(cost).toBe(null);
    });
    it('varList empty array of variables to update updates nothing', function (math) {
        var learningRate = .1;
        var optimizer = new sgd_optimizer_1.SGDOptimizer(learningRate);
        var x = ndarray_1.variable(ndarray_1.Scalar.new(4));
        var bias = ndarray_1.variable(ndarray_1.Scalar.new(1));
        var strayVariable = ndarray_1.variable(ndarray_1.Scalar.new(-1));
        var varList = [];
        var f = function () { return math.addStrict(math.square(x), bias); };
        var cost = optimizer.minimize(f, true, varList);
        test_util.expectArraysClose(x, [4]);
        test_util.expectArraysClose(bias, [1]);
        test_util.expectArraysClose(cost, [Math.pow(4, 2) + 1]);
        test_util.expectArraysClose(strayVariable, [-1]);
        cost = optimizer.minimize(f, false, varList);
        test_util.expectArraysClose(x, [4]);
        test_util.expectArraysClose(bias, [1]);
        test_util.expectArraysClose(strayVariable, [-1]);
        expect(cost).toBe(null);
    });
    it('varList subset of variables update', function (math) {
        var learningRate = .1;
        var optimizer = new sgd_optimizer_1.SGDOptimizer(learningRate);
        var x = ndarray_1.variable(ndarray_1.Scalar.new(4));
        var bias = ndarray_1.variable(ndarray_1.Scalar.new(1));
        var strayVariable = ndarray_1.variable(ndarray_1.Scalar.new(-1));
        var varList = [x];
        var f = function () { return math.addStrict(math.square(x), bias); };
        var cost = optimizer.minimize(f, true, varList);
        var expectedValue1 = -2 * 4 * learningRate + 4;
        test_util.expectArraysClose(x, [expectedValue1]);
        test_util.expectArraysClose(bias, [1]);
        test_util.expectArraysClose(cost, [Math.pow(4, 2) + 1]);
        test_util.expectArraysClose(strayVariable, [-1]);
        cost = optimizer.minimize(f, false, varList);
        var expectedValue2 = -2 * expectedValue1 * learningRate + expectedValue1;
        test_util.expectArraysClose(x, [expectedValue2]);
        test_util.expectArraysClose(bias, [1]);
        expect(cost).toBe(null);
        test_util.expectArraysClose(strayVariable, [-1]);
    });
    it('only bias trainable', function (math) {
        var learningRate = .1;
        var optimizer = new sgd_optimizer_1.SGDOptimizer(learningRate);
        var trainable = false;
        var x = ndarray_1.variable(ndarray_1.Scalar.new(4), trainable);
        var bias = ndarray_1.variable(ndarray_1.Scalar.new(1));
        var strayVariable = ndarray_1.variable(ndarray_1.Scalar.new(-1));
        var f = function () { return math.addStrict(math.square(x), bias); };
        var cost = optimizer.minimize(f, true);
        test_util.expectArraysClose(x, [4]);
        var expectedBias1 = -1 * learningRate + 1;
        test_util.expectArraysClose(bias, [expectedBias1]);
        test_util.expectArraysClose(cost, [Math.pow(4, 2) + 1]);
        test_util.expectArraysClose(strayVariable, [-1]);
        cost = optimizer.minimize(f, false);
        test_util.expectArraysClose(x, [4]);
        var expectedBias2 = -learningRate + expectedBias1;
        test_util.expectArraysClose(bias, [expectedBias2]);
        expect(cost).toBe(null);
        test_util.expectArraysClose(strayVariable, [-1]);
    });
    it('only bias trainable, only x in varList does nothing', function (math) {
        var learningRate = .1;
        var optimizer = new sgd_optimizer_1.SGDOptimizer(learningRate);
        var trainable = false;
        var x = ndarray_1.variable(ndarray_1.Scalar.new(4), trainable);
        var bias = ndarray_1.variable(ndarray_1.Scalar.new(1));
        var strayVariable = ndarray_1.variable(ndarray_1.Scalar.new(-1));
        var varList = [x];
        var f = function () { return math.addStrict(math.square(x), bias); };
        var cost = optimizer.minimize(f, true, varList);
        test_util.expectArraysClose(x, [4]);
        test_util.expectArraysClose(bias, [1]);
        test_util.expectArraysClose(cost, [Math.pow(4, 2) + 1]);
        test_util.expectArraysClose(strayVariable, [-1]);
        cost = optimizer.minimize(f, false, varList);
        test_util.expectArraysClose(x, [4]);
        test_util.expectArraysClose(bias, [1]);
        expect(cost).toBe(null);
        test_util.expectArraysClose(strayVariable, [-1]);
    });
};
test_util.describeMathCPU('Optimizer', [tests]);
test_util.describeMathGPU('Optimizer', [tests], [
    { 'WEBGL_FLOAT_TEXTURE_ENABLED': true, 'WEBGL_VERSION': 1 },
    { 'WEBGL_FLOAT_TEXTURE_ENABLED': true, 'WEBGL_VERSION': 2 },
    { 'WEBGL_FLOAT_TEXTURE_ENABLED': false, 'WEBGL_VERSION': 1 }
]);
//# sourceMappingURL=optimizer_test.js.map