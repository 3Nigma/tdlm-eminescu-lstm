"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var environment_1 = require("../../environment");
var concat_util = require("../../math/concat_util");
var ndarray_1 = require("../../math/ndarray");
var graph_1 = require("../graph");
var tensor_array_map_1 = require("../tensor_array_map");
var concat_1 = require("./concat");
describe('concat operation', function () {
    var math = environment_1.ENV.math;
    var x1Tensor;
    var x2Tensor;
    var yTensor;
    var concatOperation;
    var tensorArrayMap;
    var gradientArrays;
    beforeEach(function () {
        tensorArrayMap = new tensor_array_map_1.TensorArrayMap();
        gradientArrays = new tensor_array_map_1.SummedTensorArrayMap(math);
    });
    afterEach(function () {
        tensorArrayMap.disposeArray(x1Tensor);
        tensorArrayMap.disposeArray(x2Tensor);
        tensorArrayMap.disposeArray(yTensor);
    });
    it('concats 1d tensors', function () {
        var x1 = ndarray_1.Array1D.new([1, 1, 3]);
        var x2 = ndarray_1.Array1D.new([2, 2]);
        x1Tensor = new graph_1.Tensor(x1.shape);
        x2Tensor = new graph_1.Tensor(x2.shape);
        yTensor = new graph_1.Tensor(concat_util.computeOutShape1D(x1.shape, x2.shape));
        tensorArrayMap.set(x1Tensor, x1);
        tensorArrayMap.set(x2Tensor, x2);
        concatOperation = new concat_1.Concat1D(x1Tensor, x2Tensor, yTensor);
        concatOperation.feedForward(math, tensorArrayMap);
        var y = tensorArrayMap.get(yTensor);
        expect(y.shape).toEqual([5]);
        expect(y.getValues()).toEqual(new Float32Array([1, 1, 3, 2, 2]));
        gradientArrays.add(yTensor, ndarray_1.Array1D.new([1, 2, 3, 4, 5]));
        concatOperation.backProp(math, tensorArrayMap, gradientArrays);
        var dx1 = gradientArrays.get(x1Tensor);
        var dx2 = gradientArrays.get(x2Tensor);
        expect(dx1.shape).toEqual([3]);
        expect(dx1.getValues()).toEqual(new Float32Array([1, 2, 3]));
        expect(dx2.shape).toEqual([2]);
        expect(dx2.getValues()).toEqual(new Float32Array([4, 5]));
    });
    it('concats 2d tensors, axis=0', function () {
        var x1 = ndarray_1.Array2D.new([2, 3], [[1, 1, 3], [2, 2, 3]]);
        var x2 = ndarray_1.Array2D.new([1, 3], [[3, 3, 4]]);
        x1Tensor = new graph_1.Tensor(x1.shape);
        x2Tensor = new graph_1.Tensor(x2.shape);
        yTensor = new graph_1.Tensor(concat_util.computeOutShape(x1.shape, x2.shape, 0));
        tensorArrayMap.set(x1Tensor, x1);
        tensorArrayMap.set(x2Tensor, x2);
        concatOperation = new concat_1.Concat2D(x1Tensor, x2Tensor, 0, yTensor);
        concatOperation.feedForward(math, tensorArrayMap);
        var y = tensorArrayMap.get(yTensor);
        expect(y.shape).toEqual([3, 3]);
        expect(y.getValues()).toEqual(new Float32Array([1, 1, 3, 2, 2, 3, 3, 3, 4]));
        gradientArrays.add(yTensor, ndarray_1.Array2D.new([3, 3], [[1, 2, 3], [4, 5, 6], [7, 8, 9]]));
        concatOperation.backProp(math, tensorArrayMap, gradientArrays);
        var dx1 = gradientArrays.get(x1Tensor);
        var dx2 = gradientArrays.get(x2Tensor);
        expect(dx1.shape).toEqual([2, 3]);
        expect(dx1.getValues()).toEqual(new Float32Array([1, 2, 3, 4, 5, 6]));
        expect(dx2.shape).toEqual([1, 3]);
        expect(dx2.getValues()).toEqual(new Float32Array([7, 8, 9]));
    });
    it('concats 2d tensors, axis=1', function () {
        var x1 = ndarray_1.Array2D.new([2, 3], [[1, 1, 3], [2, 2, 3]]);
        var x2 = ndarray_1.Array2D.new([2, 1], [[3], [4]]);
        x1Tensor = new graph_1.Tensor(x1.shape);
        x2Tensor = new graph_1.Tensor(x2.shape);
        yTensor = new graph_1.Tensor(concat_util.computeOutShape(x1.shape, x2.shape, 1));
        tensorArrayMap.set(x1Tensor, x1);
        tensorArrayMap.set(x2Tensor, x2);
        concatOperation = new concat_1.Concat2D(x1Tensor, x2Tensor, 1, yTensor);
        concatOperation.feedForward(math, tensorArrayMap);
        var y = tensorArrayMap.get(yTensor);
        expect(y.shape).toEqual([2, 4]);
        expect(y.getValues()).toEqual(new Float32Array([1, 1, 3, 3, 2, 2, 3, 4]));
        gradientArrays.add(yTensor, ndarray_1.Array2D.new([2, 4], [[1, 2, 3, 4], [4, 5, 6, 7]]));
        concatOperation.backProp(math, tensorArrayMap, gradientArrays);
        var dx1 = gradientArrays.get(x1Tensor);
        var dx2 = gradientArrays.get(x2Tensor);
        expect(dx1.shape).toEqual([2, 3]);
        expect(dx1.getValues()).toEqual(new Float32Array([1, 2, 3, 4, 5, 6]));
        expect(dx2.shape).toEqual([2, 1]);
        expect(dx2.getValues()).toEqual(new Float32Array([4, 7]));
    });
    it('concats tensors, axis=0', function () {
        var axis = 0;
        var x1 = ndarray_1.Array3D.new([1, 1, 3], [1, 2, 3]);
        var x2 = ndarray_1.Array3D.new([1, 1, 3], [4, 5, 6]);
        x1Tensor = new graph_1.Tensor(x1.shape);
        x2Tensor = new graph_1.Tensor(x2.shape);
        yTensor = new graph_1.Tensor(concat_util.computeOutShape(x1.shape, x2.shape, axis));
        tensorArrayMap.set(x1Tensor, x1);
        tensorArrayMap.set(x2Tensor, x2);
        concatOperation = new concat_1.Concat3D(x1Tensor, x2Tensor, axis, yTensor);
        concatOperation.feedForward(math, tensorArrayMap);
        var y = tensorArrayMap.get(yTensor);
        expect(y.shape).toEqual([2, 1, 3]);
        expect(y.getValues()).toEqual(new Float32Array([1, 2, 3, 4, 5, 6]));
        gradientArrays.add(yTensor, ndarray_1.Array3D.new([2, 1, 3], [1, 2, 3, 4, 5, 6]));
        concatOperation.backProp(math, tensorArrayMap, gradientArrays);
        var dx1 = gradientArrays.get(x1Tensor);
        var dx2 = gradientArrays.get(x2Tensor);
        expect(dx1.shape).toEqual([1, 1, 3]);
        expect(dx1.getValues()).toEqual(new Float32Array([1, 2, 3]));
        expect(dx2.shape).toEqual([1, 1, 3]);
        expect(dx2.getValues()).toEqual(new Float32Array([4, 5, 6]));
    });
    it('concats tensors, axis=1', function () {
        var axis = 1;
        var x1 = ndarray_1.Array3D.new([1, 1, 3], [1, 2, 3]);
        var x2 = ndarray_1.Array3D.new([1, 1, 3], [4, 5, 6]);
        x1Tensor = new graph_1.Tensor(x1.shape);
        x2Tensor = new graph_1.Tensor(x2.shape);
        yTensor = new graph_1.Tensor(concat_util.computeOutShape(x1.shape, x2.shape, axis));
        tensorArrayMap.set(x1Tensor, x1);
        tensorArrayMap.set(x2Tensor, x2);
        concatOperation = new concat_1.Concat3D(x1Tensor, x2Tensor, axis, yTensor);
        concatOperation.feedForward(math, tensorArrayMap);
        var y = tensorArrayMap.get(yTensor);
        expect(y.shape).toEqual([1, 2, 3]);
        expect(y.getValues()).toEqual(new Float32Array([1, 2, 3, 4, 5, 6]));
        gradientArrays.add(yTensor, ndarray_1.Array3D.new([1, 2, 3], [1, 2, 3, 4, 5, 6]));
        concatOperation.backProp(math, tensorArrayMap, gradientArrays);
        var dx1 = gradientArrays.get(x1Tensor);
        var dx2 = gradientArrays.get(x2Tensor);
        expect(dx1.shape).toEqual([1, 1, 3]);
        expect(dx1.getValues()).toEqual(new Float32Array([1, 2, 3]));
        expect(dx2.shape).toEqual([1, 1, 3]);
        expect(dx2.getValues()).toEqual(new Float32Array([4, 5, 6]));
    });
    it('concats tensors, axis=2', function () {
        var axis = 2;
        var x1 = ndarray_1.Array3D.new([1, 1, 3], [1, 2, 3]);
        var x2 = ndarray_1.Array3D.new([1, 1, 3], [4, 5, 6]);
        x1Tensor = new graph_1.Tensor(x1.shape);
        x2Tensor = new graph_1.Tensor(x2.shape);
        yTensor = new graph_1.Tensor(concat_util.computeOutShape(x1.shape, x2.shape, axis));
        tensorArrayMap.set(x1Tensor, x1);
        tensorArrayMap.set(x2Tensor, x2);
        concatOperation = new concat_1.Concat3D(x1Tensor, x2Tensor, axis, yTensor);
        concatOperation.feedForward(math, tensorArrayMap);
        var y = tensorArrayMap.get(yTensor);
        expect(y.shape).toEqual([1, 1, 6]);
        expect(y.getValues()).toEqual(new Float32Array([1, 2, 3, 4, 5, 6]));
        gradientArrays.add(yTensor, ndarray_1.Array3D.new([1, 1, 6], [1, 2, 3, 4, 5, 6]));
        concatOperation.backProp(math, tensorArrayMap, gradientArrays);
        var dx1 = gradientArrays.get(x1Tensor);
        var dx2 = gradientArrays.get(x2Tensor);
        expect(dx1.shape).toEqual([1, 1, 3]);
        expect(dx1.getValues()).toEqual(new Float32Array([1, 2, 3]));
        expect(dx2.shape).toEqual([1, 1, 3]);
        expect(dx2.getValues()).toEqual(new Float32Array([4, 5, 6]));
    });
    it('concats 4d tensors, axis=0', function () {
        var x1 = ndarray_1.Array4D.new([1, 1, 1, 3], [1, 2, 3]);
        var x2 = ndarray_1.Array4D.new([1, 1, 1, 3], [4, 5, 6]);
        x1Tensor = new graph_1.Tensor(x1.shape);
        x2Tensor = new graph_1.Tensor(x2.shape);
        yTensor = new graph_1.Tensor(concat_util.computeOutShape(x1.shape, x2.shape, 0));
        tensorArrayMap.set(x1Tensor, x1);
        tensorArrayMap.set(x2Tensor, x2);
        concatOperation = new concat_1.Concat4D(x1Tensor, x2Tensor, 0, yTensor);
        concatOperation.feedForward(math, tensorArrayMap);
        var y = tensorArrayMap.get(yTensor);
        expect(y.shape).toEqual([2, 1, 1, 3]);
        expect(y.getValues()).toEqual(new Float32Array([1, 2, 3, 4, 5, 6]));
        gradientArrays.add(yTensor, ndarray_1.Array4D.new([2, 1, 1, 3], [1, 2, 3, 4, 5, 6]));
        concatOperation.backProp(math, tensorArrayMap, gradientArrays);
        var dx1 = gradientArrays.get(x1Tensor);
        var dx2 = gradientArrays.get(x2Tensor);
        expect(dx1.shape).toEqual([1, 1, 1, 3]);
        expect(dx1.getValues()).toEqual(new Float32Array([1, 2, 3]));
        expect(dx2.shape).toEqual([1, 1, 1, 3]);
        expect(dx2.getValues()).toEqual(new Float32Array([4, 5, 6]));
    });
    it('concats 4d tensors, axis=1', function () {
        var x1 = ndarray_1.Array4D.new([1, 1, 1, 3], [1, 2, 3]);
        var x2 = ndarray_1.Array4D.new([1, 1, 1, 3], [4, 5, 6]);
        x1Tensor = new graph_1.Tensor(x1.shape);
        x2Tensor = new graph_1.Tensor(x2.shape);
        yTensor = new graph_1.Tensor(concat_util.computeOutShape(x1.shape, x2.shape, 1));
        tensorArrayMap.set(x1Tensor, x1);
        tensorArrayMap.set(x2Tensor, x2);
        concatOperation = new concat_1.Concat4D(x1Tensor, x2Tensor, 1, yTensor);
        concatOperation.feedForward(math, tensorArrayMap);
        var y = tensorArrayMap.get(yTensor);
        expect(y.shape).toEqual([1, 2, 1, 3]);
        expect(y.getValues()).toEqual(new Float32Array([1, 2, 3, 4, 5, 6]));
        gradientArrays.add(yTensor, ndarray_1.Array4D.new([1, 2, 1, 3], [1, 2, 3, 4, 5, 6]));
        concatOperation.backProp(math, tensorArrayMap, gradientArrays);
        var dx1 = gradientArrays.get(x1Tensor);
        var dx2 = gradientArrays.get(x2Tensor);
        expect(dx1.shape).toEqual([1, 1, 1, 3]);
        expect(dx1.getValues()).toEqual(new Float32Array([1, 2, 3]));
        expect(dx2.shape).toEqual([1, 1, 1, 3]);
        expect(dx2.getValues()).toEqual(new Float32Array([4, 5, 6]));
    });
});
//# sourceMappingURL=concat_test.js.map