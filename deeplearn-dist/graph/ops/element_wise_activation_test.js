"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var environment_1 = require("../../environment");
var ndarray_1 = require("../../math/ndarray");
var test_util = require("../../test_util");
var test_util_1 = require("../../test_util");
var graph_1 = require("../graph");
var tensor_array_map_1 = require("../tensor_array_map");
var element_wise_activation_1 = require("./element_wise_activation");
describe('Element wise activation', function () {
    var math = environment_1.ENV.math;
    var xTensor;
    var yTensor;
    var activations;
    var gradients;
    beforeEach(function () {
        activations = new tensor_array_map_1.TensorArrayMap();
        gradients = new tensor_array_map_1.SummedTensorArrayMap(math);
    });
    afterEach(function () {
        activations.disposeArray(xTensor);
        activations.disposeArray(yTensor);
        gradients.disposeArray(xTensor);
        gradients.disposeArray(yTensor);
    });
    it('ReLU', function () {
        var x = ndarray_1.Array2D.new([2, 3], [3, 0, -1, 2, 9, -5]);
        xTensor = new graph_1.Tensor(x.shape);
        yTensor = new graph_1.Tensor(x.shape);
        activations.set(xTensor, x);
        var op = new element_wise_activation_1.ReLU(xTensor, yTensor);
        op.feedForward(math, activations);
        var y = activations.get(yTensor);
        expect(y.dataSync()).toEqual(new Float32Array([3, 0, 0, 2, 9, 0]));
        var dy = ndarray_1.Array2D.new([2, 3], [1, 2, 3, 4, 5, 6]);
        gradients.add(yTensor, dy);
        op.backProp(math, activations, gradients);
        var dx = gradients.get(xTensor);
        expect(dx.dataSync()).toEqual(new Float32Array([1, 0, 0, 4, 5, 0]));
    });
    it('LeakyReLU', function () {
        var x = ndarray_1.Array2D.new([2, 3], [3, 0.1, -1, 2, 9, -5]);
        xTensor = new graph_1.Tensor(x.shape);
        yTensor = new graph_1.Tensor(x.shape);
        activations.set(xTensor, x);
        var op = new element_wise_activation_1.LeakyReLU(xTensor, yTensor, 0.2);
        op.feedForward(math, activations);
        var y = activations.get(yTensor);
        test_util_1.expectArraysClose(y.dataSync(), new Float32Array([3, 0.1, -0.2, 2, 9, -1.0]));
        var dy = ndarray_1.Array2D.new([2, 3], [1, 2, 3, 4, 5, 6]);
        gradients.add(yTensor, dy);
        op.backProp(math, activations, gradients);
        var dx = gradients.get(xTensor);
        test_util_1.expectArraysClose(dx.dataSync(), new Float32Array([1, 2, 0.6, 4, 5, 1.2]));
    });
    it('TanH', function () {
        var x = ndarray_1.Array1D.new([3, 0, -3]);
        xTensor = new graph_1.Tensor(x.shape);
        yTensor = new graph_1.Tensor(x.shape);
        activations.set(xTensor, x);
        var op = new element_wise_activation_1.TanH(xTensor, yTensor);
        op.feedForward(math, activations);
        var y = activations.get(yTensor);
        test_util.expectNumbersClose(y.get(0), 0.99505475);
        test_util.expectNumbersClose(y.get(1), 0);
        test_util.expectNumbersClose(y.get(2), -0.99505475);
        var dy = ndarray_1.Array1D.new([2, 4, 3]);
        gradients.add(yTensor, dy);
        op.backProp(math, activations, gradients);
        var dx = gradients.get(xTensor);
        test_util.expectNumbersClose(dx.get(0), 2 * (1 - 0.99505475 * 0.99505475));
        test_util.expectNumbersClose(dx.get(1), 4);
        test_util.expectNumbersClose(dx.get(2), 3 * (1 - 0.99505475 * 0.99505475));
    });
    it('Sigmoid', function () {
        var x = ndarray_1.Array1D.new([3, 0, -3]);
        xTensor = new graph_1.Tensor(x.shape);
        yTensor = new graph_1.Tensor(x.shape);
        activations.set(xTensor, x);
        var op = new element_wise_activation_1.Sigmoid(xTensor, yTensor);
        op.feedForward(math, activations);
        var y = activations.get(yTensor);
        test_util.expectNumbersClose(y.get(0), 0.9525741268);
        test_util.expectNumbersClose(y.get(1), 0.5);
        test_util.expectNumbersClose(y.get(2), 0.0474258731);
        var dy = ndarray_1.Array1D.new([2, 4, 3]);
        gradients.add(yTensor, dy);
        op.backProp(math, activations, gradients);
        var dx = gradients.get(xTensor);
        test_util.expectNumbersClose(dx.get(0), 2 * 0.9525741268 * (1 - 0.9525741268));
        test_util.expectNumbersClose(dx.get(1), 4 * 0.5 * 0.5);
        test_util.expectNumbersClose(dx.get(2), 3 * 0.0474258731 * (1 - 0.0474258731));
    });
    it('Square', function () {
        var x = ndarray_1.Array1D.new([2, 0, -3]);
        xTensor = new graph_1.Tensor(x.shape);
        yTensor = new graph_1.Tensor(x.shape);
        activations.set(xTensor, x);
        var op = new element_wise_activation_1.Square(xTensor, yTensor);
        op.feedForward(math, activations);
        var y = activations.get(yTensor);
        expect(y.dataSync()).toEqual(new Float32Array([4, 0, 9]));
        var dy = ndarray_1.Array1D.new([1, 2, 3]);
        gradients.add(yTensor, dy);
        op.backProp(math, activations, gradients);
        var dx = gradients.get(xTensor);
        expect(dx.get(0)).toBe(2 * x.get(0) * dy.get(0));
        expect(dx.get(1)).toBe(2 * x.get(1) * dy.get(1));
        expect(dx.get(2)).toBe(2 * x.get(2) * dy.get(2));
    });
});
//# sourceMappingURL=element_wise_activation_test.js.map